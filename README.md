# dumbugger
Простой отладчик, который мало что умеет, но с задачей справляется.

## Описание

Это отладчик, который поддерживает ограниченное количество (в сравнении с другими отладчиками) возможных операций:
- Поставить/удалить точку останова
- Просмотреть и изменить значения регистров
- Дизассемблировать текущие инструкции
- Показать исходный код текущей инструкции
- Вывести список функций, определенных в бинаре

Для контроля выполнения есть 3 команды: выполнить одну инструкцию, выполнить одну строку исходного кода, продолжить выполнение.

## Использование

В аргументах передается путь до исполняемого файла, который надо отладить, и аргументы, которые ему будут переданы.

```sh
dumbugger ./sample 1 3
```

После этого будет запущена указанная программа с аргументами.

Когда процесс остановится, то станет возможно управление им (изменение состояния, печать исходного кода и т.д.).
Это можно понять по prompt\`у `(dmbg)`

Например, после запуска, можно посмотреть все определенные функции и поставить точку останова у одной из них:

```sh
(dmbg) functions show
functions:
    main
    sample_function
(dmbg) bp sample_function
(dmbg) continue
```

## Установка

Для работы требуются зависимости:

- libopcodes - для дизассемблирования
- libdwarf - для чтения отладочных символов

Каждую из них можно найти в соответствующей директории.
В каждой из них есть свои Makefile, которые эти зависимости установят: 
скачают, распакуют, настроят, соберут.

```sh
# libopcodes
make -C src/libopcodes all
# libdwarf
make -C src/libdwarf all
```

Файлы самого отладчика находятся в `src/dumbugger`. 
Там же находится и Makefile.

```sh
# dumbugger
make -C src/dumbugger all
```

Для удобства имеется Makefile в корне. 
Он может установить библиотеки и сам отладчик.

```sh
# Из корня проекта
make all
# libopcodes
make libopcodes
# libdwarf
make libdwarf
# dumbugger
make dumbugger
```

Также в `src/dumbugger` находится sample.c - проект-пример.
Для его сборки используется Makefile в этой директории.

```sh
make -C src/dumbugger sample
```

## Пример работы

### Точка останова

Точки останова можно ставить, используя 3 типа описания:

- Адрес напрямую
- Название функции
- Строка файла исходного кода

```sh
# Адрес
(dmbg) bp 0x1AF334350B

# Название функции
(dmbg) bp sample_function

# Строка файла исходного кода
(dmbg) bp sample.c:9
```

### Продолжение работы

```sh
(dmbg) cont
(dmbg) continue
```

После этой команды, работа отслеживаемого процесса продолжается, пока не будет достигнута следующая точка останова.

### Выполнение шагов

Есть 2 типа шага:
- Выполнение инструкции
- Выполнение строки исходного кода

```sh
# Инструкция
(dmbg) si
# Строка исходного кода
(dmbg) s
(dmbg) step
```

Причем, шаг в исходном коде - значит, останавливаемся когда текущая строка закончила выполнение.
Это похоже на `step in` поведение. Есть еще `step out` и `step over`, но я их не захотел реализовывать.

### Вывод функций

```sh
(dmbg) functions show
```

Эта команда выведет названия функций, которые определены в исходниках.
По большей части, это нужно, чтобы правильно выставить точки останова в процессе работы.

### Дизассемблирование/Исходный код

```sh
# Дизассемблирование
(dmbg) disasm
# Исходный код
(dmbg) src
```

Есть поддержка дизассемблирования. Она реализуется с помощью libopcodes.
Но единственный минус - если перед инструкциями впереди есть точка останова, то скорее всего 
в выводе будет мусор.

Для вывода исходного кода читается сам файл исходного кода, поэтому если он был
изменен в процессе отладки, то визуализация может сбиться.

### Регистры

```sh
# Показать значения регистров
(dmbg) regs show
# Выставить значение регистра NAME в VALUE
(dmbg) regs set NAME VALUE
```

Для управления регистрами есть 2 команды: показать и изменить.
Сейчас, есть возможность управления только 3 регистрами: rdx, rdi, rsi.

### Другое

```sh
# Показать окно команд
(dmbg) help
```

## Ограничения/недостатки/проблемы

Этот проект не для прода, а больше для обучения.
Проблем множество, но обобщая - это работает на моей машине:

- Архитектура и битность
- ОС
- Версии зависимостей
- Установленные неявные зависимости

Также многое я сделал для своего удобства и не думал о том, чтобы делать из этого готовый продукт.

Работа проверялась на happy-path - я не гарантирую, что все и всегда будет работать корректно. 
Например, дисассемблирование инструкций, если впереди поставлена точка останова (т.е. изменили инструкции)
приведет к мусору в выводе.
